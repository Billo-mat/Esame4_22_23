import pandas as pd

# 1. Caricamento del dataset
# Usiamo sep=';' perché il file utilizza il punto e virgola come separatore
df_plants = pd.read_csv('Plant_data.csv', sep=';')

# 2. Creazione della colonna 'wooden'
# La colonna sarà True se Plant_part è "wood" oppure "bark"
df_plants['wooden'] = df_plants['Plant_part'].isin(['wood', 'bark'])

# 3. Verifica del risultato
print(df_plants[['Plant_part', 'wooden']].head())

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# 1. Caricamento e funzione
df_plants = pd.read_csv('Plant_data.csv', sep=';')

def gaussian(x, mu, sigma):
    if sigma <= 0: return np.zeros_like(x)
    return (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mu) / sigma)**2)

valid_gaussians = df_plants.dropna(subset=['d15N_sd']).copy()

# 2. Creazione griglia ORDINATA
# sharex=True e sharey=True eliminano la ripetizione dei numeri sugli assi interni
fig, axes = plt.subplots(6, 3, figsize=(16, 22), sharex=True)
axes = axes.flatten()

x_range = np.linspace(-5, 25, 1000)

for i, (idx, row) in enumerate(valid_gaussians.iterrows()):
    mu, sigma = row['d15N'], row['d15N_sd']
    ax = axes[i]
    
    if sigma > 0:
        y = gaussian(x_range, mu, sigma)
        ax.plot(x_range, y, color='darkgreen', lw=1.5)
        ax.fill_between(x_range, y, alpha=0.2, color='green')
    else:
        ax.axvline(mu, color='red', linestyle='--', alpha=0.7)
        ax.text(mu, 0.5, '$\sigma=0$', color='red', transform=ax.get_xaxis_transform())

    # Titolo piccolo e pulito dentro il box o appena sopra
    ax.set_title(f"{row['Species'][:20]}...", fontsize=9, pad=3)
    ax.grid(True, linestyle=':', alpha=0.3)

# 3. REGOLAZIONE SPAZI (Il punto cruciale)
# hspace: spazio verticale tra i grafici
# wspace: spazio orizzontale tra i grafici
fig.subplots_adjust(hspace=0.6, wspace=0.3, top=0.95, bottom=0.05, left=0.1, right=0.9)

# Etichette globali per gli assi (per non ripeterle 18 volte)
fig.text(0.5, 0.02, 'd15N Mean Value', ha='center', fontsize=14)
fig.text(0.04, 0.5, 'Probability Density', va='center', rotation='vertical', fontsize=14)

plt.savefig('plant_gaussians_ordered.png', dpi=300)
plt.show()

def secret_sauce(plant_type: str, d13c: float, percentage: float) -> float:
    """
    Applica una percentuale al valore d13C in base al tipo di pianta.
    
    Se la pianta è "C3", restituisce d13C * percentage.
    Se la pianta è "C4", restituisce d13C * (1 - percentage).

    >>> secret_sauce("C3", 30.0, 0.1)
    3.0
    >>> secret_sauce("C4", 30.0, 0.1)
    27.0
    """
    if plant_type == "C3":
        return d13c * percentage
    elif plant_type == "C4":
        return d13c * (1 - percentage)
    else:
        # Opzionale: gestione di tipi non previsti
        return 0.0

# Per eseguire il test automatico incluso nella docstring:
if __name__ == "__main__":
    import doctest
    doctest.testmod()

# 1. Applichiamo la funzione secret_sauce riga per riga
# Dividiamo C_cont per 100 per scalarlo correttamente (da 0-100 a 0-1)
df_plants['sauce_result'] = df_plants.apply(
    lambda row: secret_sauce(row['Plant_type'], row['d13C'], row['C_cont'] / 100), 
    axis=1
)

# 2. Visualizziamo i primi risultati per conferma
print(df_plants[['Plant_type', 'd13C', 'C_cont', 'sauce_result']].head())

import pandas as pd
import matplotlib.pyplot as plt

# 1. Caricamento del dataset
df_plants = pd.read_csv('Plant_data.csv', sep=';')

# 2. Creazione dello scatter plot
plt.figure(figsize=(10, 6))

# Tipi unici di parti della pianta per gestire colori e legenda
plant_parts = df_plants['Plant_part'].unique()

# Iteriamo su ogni parte della pianta per disegnarla con un colore diverso
for part in plant_parts:
    subset = df_plants[df_plants['Plant_part'] == part]
    plt.scatter(subset['d13C'], subset['d15N'], label=part, alpha=0.7, edgecolors='w', s=60)

# 3. Formattazione del grafico
plt.title('Scatter plot of d13C vs. d15N')
plt.xlabel('d13C (‰)')
plt.ylabel('d15N (‰)')
plt.legend(title='Plant Part', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True, linestyle='--', alpha=0.5)

# 4. Salvataggio
plt.tight_layout() # Per evitare che la legenda venga tagliata
plt.show()

# 2. Filtraggio per le "acaciae"
# Cerchiamo tutte le righe dove la colonna 'Species' contiene la parola "Acacia"
acacia_df = df_plants[df_plants['Species'].str.contains('Acacia', case=False)].copy()

# 3. Calcolo della somma di d13C e d15N
# Creiamo una serie temporanea con la somma dei due valori
acacia_sum = acacia_df['d13C'] + acacia_df['d15N']

# 4. Calcolo di media e deviazione standard
mean_acacia = acacia_sum.mean()
std_acacia = acacia_sum.std()

# 5. Stampa dei risultati
print(f"Media della somma (d13C + d15N): {mean_acacia:.4f}")
print(f"Deviazione standard della somma: {std_acacia:.4f}")



import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pymc as pm
import arviz as az

# 1. Caricamento dati
# Assicurati che il file Plant_data.csv sia nella stessa cartella dello script
df_plants = pd.read_csv('Plant_data.csv', sep=';')

# 2. Definizione del modello
# Utilizziamo C_cont come predittore (C) e N_cont come variabile osservata
with pm.Model() as model:
    # Parametri alpha e beta (Priors)
    # Media 0, Deviazione Standard 5
    alpha = pm.Normal('alpha', mu=0, sigma=5)
    beta = pm.Normal('beta', mu=0, sigma=5)
    
    # Sigma (errore) - Distribuzione esponenziale con lambda = 1
    sigma = pm.Exponential('sigma', lam=1)
    
    # Media della distribuzione (mu)
    # Equation: alpha + beta * C_cont
    mu = alpha + beta * df_plants['C_cont'].values
    
    # Likelihood (Verosimiglianza)
    # L'osservato N_cont è distribuito normalmente attorno a mu con deviazione sigma
    y_obs = pm.Normal('y_obs', mu=mu, sigma=sigma, observed=df_plants['N_cont'].values)
    
    # 3. Campionamento
    # Esegue l'algoritmo NUTS per stimare i parametri
    trace = pm.sample(1000, tune=1000, chains=2, return_inferencedata=True)

# 4. Visualizzazione dei risultati
# Genera il grafico della distribuzione a posteriori (come richiesto)
az.plot_posterior(trace)
plt.tight_layout()
plt.show()

# Stampa il riassunto statistico (media, hdi, ecc.)
print(az.summary(trace))
